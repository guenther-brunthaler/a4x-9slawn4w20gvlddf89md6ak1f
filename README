ARCFOUR-XA-drop3072
===================
v2019.351

The utility encrypts or decrypts standard input to standard output, using the path name of a user-provided key file as its only non-option argument.

Either option -e (for encryption) or -d (for decryption) is mandatory in order to specify the operation to be performed.

The utiltity combines the standard ARCFOUR stream cipher algorithm with an augmented key setup and a customized mode of operation in order to make it more secure.

All encryptions will be salted, allowing safe re-use of the same encryption key for different messages, even if the messages happen to be identical.

Also, an ARCFOUR-based message authentication code will be added to every encrypted message ("encrypt-then-MAC"), detecting any manipulation or corruption of the encrypted message.


Basic ARCFOUR Algorithm
-----------------------

This as a generalized description of the standard ARCFOUR algorithm, which is used for both key setup and cryptographically-secure pseudorandom generation:

1. i= j= 0; s[all indices mod 256]
2. Preset s[i]= 0 .. 255
3. Move i one position to the right
4. Move j by (s[i] + optional_next_key_octet()) positions to the right
5. Swap s[] values at indices i and j.
6. Optionally output s[index equal to sum of values just swapped]
7. Go back to step 3 unless finished

Details:

* This basic algorithm is the same for standard ARCFOUR implementations as well as for the extended ARCFOUR-XA-drop3072 algorithm.

* As hinted by step 1, all indexes to array s[] have to be reduced modulo the array's size, which is 256 elements. This is not explicitly mentioned in the remaining steps, but has to be applied there too.

* optional_next_key_octet() is a function which provides the next input key material octet. It is only used in the key setup phase and always yields 0 during normal operation.

* In the standard ARCFOUR algorithm's key setup phase, optional_next_key_octet() always returns key[i modulo keysize] and the key setup phase ends at step 7 after 256 octets have been produced by optional_next_key_octet().

* Step 2 is only used during key setup. It is skipped during normal operation.

* Step 6 is only used during normal operation. It is skipped during key setup.

* The output value optionally produced by step 6 represents a cryptographically-secure pseudo random number sequence which is completely pre-determined by the key used in the key setup phase.

* In the standard ARCFOUR algorithm, the CPRNG-sequence produced by step 6 is directly XORed with the input stream in order to encrypt or decrypt it.


Augmented key setup
-------------------

As mentioned before, ARCFOUR-XA-drop3072 does not use the standard ARCFOUR key setup, but rather an augmented version of it.

* If the key size is exactly 256 octets, the original ARCFOUR key setup algorithm is used unchanged.

* If the key size is greater than 256 octets, the original ARCFOUR key setup is used unchanged for the first 256 octets, but it is then forcefully continued until all octets of the key have been processed. It only stops at step 7 after the last octet of the key has been processed.

* If the key size is less then 256 octets, it is stretched into at least 256 + 2 octets using the following simple algorithm: Key segments constructed from the key are repeated as few times as possible in order for the combined length of the segments to reach at least the same size that a key segment formed for a key of 256 octets would have. Every key segment consists of the concatenation of the key, the key size (which may be 0), and a repetition counter (starting with 0). Both the key size and the counter are stored as an octet. That means every segment used for key stretching has the size of the key plus 2 octets. After stretching the key, the augmented key setup as explained for the other cases is used to actually process the stretched key.

* After processing all octets of the (possibly stretched) key as explained above, step 1 of the generalized description is executed again. Then the normal standard ARCFOUR algorithm is run 3072 (= 4 * 768) times in order to "warm up" the CPRNG and protect against several known attacks on standard ARCFOUR (which does not do such warmup). The output octets generated during this warmup phase are not used and just thrown away.


XA Mode of Operation
--------------------

ARCFOUR-XA-drop3072 uses the XA mode of operation rather than the standard ARCFOUR method which simply XORs CPRNG octets into the input stream in order to create the output stream.

ARCFOUR-XA consumes 2 CPRNG octets for every encryption instead, and works as follows:

C[i] = (P[i] XOR CPRNG[2 * i]) + CPRNG[2 * i + 1]
P[i] = (C[i] - CPRNG[2 * i + 1]) XOR CPRNG[2 * i]

where "+" and "-" are addition/subtraction modulo 256 and CPRNG[j] is the jth output (assuming the first j is 0) returned by the ARCFOUR algorithm after key setup.

As one might have already guessed, 'XA' stands for "XOR-Add".


ARCFOUR-XA-drop3072-HASH
------------------------

The following cryptographically secure hash function is used as part of the message authentication process:

* The ARCFOUR-XA-drop3072 algorithm is used to encrypt an initial vector, using all octets of the message to be hashed as the key. The output of that encryption is the hash.

* The IV must have the same size as the intended output hash, and consists of all binary zeros by default. Customized versions of the hash may use other IVs, though.

* Because the size of the IV can be chosen freely, ARCFOUR-XA-drop3072-HASH can create hashes of any desired bit sizes. An instance of the algorithm generating hashes of $N bits shall be referred to as ARCFOUR-XA-drop3072-HASH-$N.


ARCFOUR-XA-drop3072 MAC
-----------------------

The ARCFOUR-XA-drop3072-HASH-512 algorithm is customized with a secret 512-bit IV instead of the all-zero default IV.

By doing so, the ARCFOUR-XA-drop3072-HASH-512 becomes the ARCFOUR-XA-drop3072-MAC-512, and the secret IV becomes the 512-bit MAC key.


Key derivation phase
--------------------

The utility used for encryption will not use ARCFOUR-XA-drop3072 directly for encryption or decryption with the user-provided key file.

Instead, the user-provided key file will be used to set up a ARCFOUR-XA-drop3072 CPRNG which shall generate multiple binary octet strings for different purposes in the following order:

* 256 octets <salt_encryption>

* 64 octets <mac_key>

* 256 octets <payload_encryption>

* optionally (only for encryption operation) 64 octets <salt_creation>

The CPRNG is derived from the encryption algorithm by encrypting an infinite stream of octets containing the value zero.


Encrypted message layout
========================

The encrypted output generated by this utility will have the following structure:

* 64 octets salt encrypted by ARCFOUR-XA-drop3072 with <salt_encryption> as encryption key

* All octets of the plaintext input message as payload encrypted with the ARCFOUR-XA-drop3072 algorithm and using <payload_encryption> as the encryption key

* 64 octets MAC calculated over all the encrypted octets before itself (i. e. over the encrypted salt and payload), using <mac_key> as the key for the ARCFOUR-XA-drop3072-MAC-512.

The encrypted output stream will therefore always be 128 octets larger than the original plaintext input stream.

The length of the input message need not be known in advance for encryption/decryption.

The position of the MAC within an encrypted input stream is detected by encountering EOF, which is known to be 64 octets after the first octet of the MAC.


Salt generation
===============

A salt only need needs to be generated for encryption.

Decryption just reads the encrypted salt from the first 64 octets of the message and uses <salt_encryption> as the key for decrypting the salt.

A new salt is generated by calculating the ARCFOUR-XA-drop3072-MAC-512 for some input with <salt_creation> as the MAC key.

The input used for salt creation is composed of the following components, fed onto the MAC calculation in arbitrary order:

* 64 octets from /dev/random, /dev/urandom or some other OS-specific "true randomness" source

* The binary output of localtime()

* The binary output of clock()

If possible, the utility should also keep a binary 512-bit per-user counter within some state file and increment this counter (ignoring overflow) for every encryption, then including its new value into the MAC also.

The counter value may (if not existing yet) be initialized using the ARCFOUR-XA-drop3072-HASH-512 over all of some of the following data items:

* The hostname as returned by `hostname -f` on Linux

* The host's IP addresses as returned by `hostname -I` on Linux

* The user/group memberships as returned by `id` on POSIX systems

* The current value of /proc/sys/kernel/random/boot_id on Linux

* The contents of file /etc/machine-id on Linux

* The contents of file /proc/cpuid on Linux

* The current result of `ps -AHlf` on Linux

* And anything else one might think of that can deliver entropy, such as the current value of performance counters provided by some CPUs.

Optionally, the above entropy sources may also be sampled regularly based on the current counter value, combining them with the old counter value into a new hash to act as the new counter value.

However, this should only be done occasionally, in order to not put too much stress on the system. For instance, once a week, by estimating the number of encryption invocations typically happening during a week. The sampling will then be triggered the next time the counter value equals a multiple of the estimated interval value.
